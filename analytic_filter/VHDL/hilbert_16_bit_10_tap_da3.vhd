-- -------------------------------------------------------------
--
-- Module: hilbert_filter
--
-- Generated by MATLAB(R) 7.4 and the Filter Design HDL Coder 2.0.
--
-- Generated on: 2007-06-27 15:40:52
--
-- -------------------------------------------------------------

-- -------------------------------------------------------------
-- HDL Code Generation Options:
--
-- TargetLanguage: VHDL
-- OptimizeForHDL: on
-- CastBeforeSum: off
-- TargetDirectory: G:\svn\PLDWORK\LIB\analytic_filter\VHDL
-- AddPipelineRegisters: on
-- Name: hilbert_filter
-- DALUTPartition: 3
--
-- Filter Settings:
--
-- Discrete-Time FIR Filter (real)
-- -------------------------------
-- Filter Structure  : Direct-Form Antisymmetric FIR
-- Filter Length     : 11
-- Stable            : Yes
-- Linear Phase      : Yes (Type 3)
-- Arithmetic        : fixed
-- Numerator         : s16,15 -> [-1 1)
-- Input             : s16,16 -> [-5.000000e-001 5.000000e-001)
-- Filter Internals  : Specify Precision
--   Output          : s16,16 -> [-5.000000e-001 5.000000e-001)
--   Tap Sum         : s17,16 -> [-1 1)
--   Product         : s32,30 -> [-2 2)
--   Accumulator     : s32,30 -> [-2 2)
--   Round Mode      : convergent
--   Overflow Mode   : wrap
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.numeric_std.ALL;

ENTITY hilbert_filter IS
   PORT( clk                             :   IN    std_logic; 
         clk_enable                      :   IN    std_logic; 
         reset                           :   IN    std_logic; 
         filter_in                       :   IN    std_logic_vector(15 DOWNTO 0); -- sfix16_En16
         filter_out                      :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En16
         );

END hilbert_filter;


----------------------------------------------------------------
--Module Architecture: hilbert_filter
----------------------------------------------------------------
ARCHITECTURE rtl OF hilbert_filter IS
  -- Local Functions
  -- Type Definitions
  TYPE delay_pipeline_type IS ARRAY (NATURAL range <>) OF std_logic; -- boolean
  -- Constants
  CONSTANT coeff1                         : signed(15 DOWNTO 0) := to_signed(-3494, 16); -- sfix16_En15
  CONSTANT coeff2                         : signed(15 DOWNTO 0) := to_signed(0, 16); -- sfix16_En15
  CONSTANT coeff3                         : signed(15 DOWNTO 0) := to_signed(-5835, 16); -- sfix16_En15
  CONSTANT coeff4                         : signed(15 DOWNTO 0) := to_signed(0, 16); -- sfix16_En15
  CONSTANT coeff5                         : signed(15 DOWNTO 0) := to_signed(-17521, 16); -- sfix16_En15
  CONSTANT coeff6                         : signed(15 DOWNTO 0) := to_signed(0, 16); -- sfix16_En15

  CONSTANT const_one                      : std_logic := '1'; -- boolean

  -- Signals
  SIGNAL filter_in_cast                   : signed(15 DOWNTO 0); -- sfix16_En16
  SIGNAL cur_count                        : unsigned(4 DOWNTO 0); -- ufix5
  SIGNAL phase_1                          : std_logic; -- boolean
  SIGNAL phase_1_1                        : std_logic; -- boolean
  SIGNAL phase_16                         : std_logic; -- boolean
  SIGNAL serialoutb1                      : std_logic; -- boolean
  SIGNAL shiftreg                         : signed(15 DOWNTO 0); -- sfix16_En16
  SIGNAL delay_pipeline                   : delay_pipeline_type(0 TO 159); -- boolean
  SIGNAL delayline_b31                    : std_logic; -- boolean
  SIGNAL delayline_b63                    : std_logic; -- boolean
  SIGNAL delayline_b95                    : std_logic; -- boolean
  SIGNAL delayline_b127                   : std_logic; -- boolean
  SIGNAL delayline_b159                   : std_logic; -- boolean
  SIGNAL preaddbit1                       : std_logic; -- boolean
  SIGNAL delayline_b159_not               : std_logic; -- boolean
  SIGNAL faddcarry1                       : std_logic; -- boolean
  SIGNAL carrymux1                        : std_logic; -- boolean
  SIGNAL carryreg1                        : std_logic; -- boolean
  SIGNAL temp1                            : std_logic; -- boolean
  SIGNAL temp2                            : std_logic; -- boolean
  SIGNAL temp3                            : std_logic; -- boolean
  SIGNAL preaddbit2                       : std_logic; -- boolean
  SIGNAL delayline_b127_not               : std_logic; -- boolean
  SIGNAL faddcarry2                       : std_logic; -- boolean
  SIGNAL carrymux2                        : std_logic; -- boolean
  SIGNAL carryreg2                        : std_logic; -- boolean
  SIGNAL temp1_1                          : std_logic; -- boolean
  SIGNAL temp2_1                          : std_logic; -- boolean
  SIGNAL temp3_1                          : std_logic; -- boolean
  SIGNAL preaddbit3                       : std_logic; -- boolean
  SIGNAL delayline_b95_not                : std_logic; -- boolean
  SIGNAL faddcarry3                       : std_logic; -- boolean
  SIGNAL carrymux3                        : std_logic; -- boolean
  SIGNAL carryreg3                        : std_logic; -- boolean
  SIGNAL temp1_2                          : std_logic; -- boolean
  SIGNAL temp2_2                          : std_logic; -- boolean
  SIGNAL temp3_2                          : std_logic; -- boolean
  SIGNAL mem_addr                         : unsigned(2 DOWNTO 0); -- ufix3
  SIGNAL memoutb1                         : signed(15 DOWNTO 0); -- sfix16_En15
  SIGNAL acc_out                          : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL memoutb1_cast                    : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL add_sub_out                      : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL acc_out_shft                     : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL acc_in                           : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL addsub_add                       : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL addsub_sub                       : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL add_temp                         : signed(34 DOWNTO 0); -- sfix35_En31
  SIGNAL sub_temp                         : signed(34 DOWNTO 0); -- sfix35_En31
  SIGNAL final_acc_out                    : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL output_da                        : signed(33 DOWNTO 0); -- sfix34_En31
  SIGNAL output_typeconvert               : signed(15 DOWNTO 0); -- sfix16_En16
  SIGNAL output_register                  : signed(15 DOWNTO 0); -- sfix16_En16


BEGIN

  -- Block Statements
  filter_in_cast <= signed(filter_in);

  Counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cur_count <= to_unsigned(16, 5);
    ELSIF clk'event AND clk = '1' THEN
      IF clk_enable = '1' THEN
        IF cur_count = to_unsigned(16, 5) THEN
          cur_count <= to_unsigned(0, 5);
        ELSE
          cur_count <= cur_count + 1;
        END IF;
      END IF;
    END IF; 
  END PROCESS Counter_process;

  phase_1 <= '1' WHEN cur_count = to_unsigned(16, 5) AND clk_enable = '1' ELSE '0';

  phase_1_1 <= '1' WHEN cur_count = to_unsigned(0, 5) AND clk_enable = '1' ELSE '0';

  phase_16 <= '1' WHEN  (((cur_count = to_unsigned(16, 5))  OR
                          (cur_count = to_unsigned(0, 5))  OR
                          (cur_count = to_unsigned(1, 5))  OR
                          (cur_count = to_unsigned(2, 5))  OR
                          (cur_count = to_unsigned(3, 5))  OR
                          (cur_count = to_unsigned(4, 5))  OR
                          (cur_count = to_unsigned(5, 5))  OR
                          (cur_count = to_unsigned(6, 5))  OR
                          (cur_count = to_unsigned(7, 5))  OR
                          (cur_count = to_unsigned(8, 5))  OR
                          (cur_count = to_unsigned(9, 5))  OR
                          (cur_count = to_unsigned(10, 5))  OR
                          (cur_count = to_unsigned(11, 5))  OR
                          (cur_count = to_unsigned(12, 5))  OR
                          (cur_count = to_unsigned(13, 5))  OR
                          (cur_count = to_unsigned(14, 5))) AND clk_enable = '1') ELSE '0';

  Serializer_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      shiftreg <= to_signed(0, 16);
    ELSIF clk'event AND clk = '1' THEN
      IF phase_16 = '1' THEN
        IF phase_1 = '1' THEN
          shiftreg <= filter_in_cast;
        ELSE
          shiftreg <= '0' & shiftreg(15 DOWNTO 1);
        END IF;
      END IF;
    END IF; 
  END PROCESS Serializer_1_process;

  serialoutb1 <= shiftreg(0);
 
  Delay_Pipeline_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delay_pipeline(0 TO 159) <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_16 = '1' THEN
        delay_pipeline(0) <= serialoutb1;
        delay_pipeline(1 TO 159) <= delay_pipeline(0 TO 158);
      END IF;
    END IF; 
  END PROCESS Delay_Pipeline_1_process;


  delayline_b31 <= delay_pipeline(31);

  delayline_b63 <= delay_pipeline(63);

  delayline_b95 <= delay_pipeline(95);

  delayline_b127 <= delay_pipeline(127);

  delayline_b159 <= delay_pipeline(159);

  delayline_b159_not <=  NOT(delayline_b159);

  preaddbit1 <=  serialoutb1 XOR delayline_b159_not XOR carrymux1;

  temp1 <=  serialoutb1 AND delayline_b159_not;

  temp2 <=  delayline_b159_not AND carrymux1;

  temp3 <=  serialoutb1 AND carrymux1;

  faddcarry1 <=  temp1 OR temp2 OR temp3;

  carrymux1 <= const_one WHEN ( phase_1_1 = '1' ) ELSE
               carryreg1;
  Carry_reg1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      carryreg1 <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF clk_enable = '1' THEN
        carryreg1 <= faddcarry1;
      END IF;
    END IF; 
  END PROCESS Carry_reg1_process;

  delayline_b127_not <=  NOT(delayline_b127);

  preaddbit2 <=  delayline_b31 XOR delayline_b127_not XOR carrymux2;

  temp1_1 <=  delayline_b31 AND delayline_b127_not;

  temp2_1 <=  delayline_b127_not AND carrymux2;

  temp3_1 <=  delayline_b31 AND carrymux2;

  faddcarry2 <=  temp1_1 OR temp2_1 OR temp3_1;

  carrymux2 <= const_one WHEN ( phase_1_1 = '1' ) ELSE
               carryreg2;
  Carry_reg2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      carryreg2 <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF clk_enable = '1' THEN
        carryreg2 <= faddcarry2;
      END IF;
    END IF; 
  END PROCESS Carry_reg2_process;

  delayline_b95_not <=  NOT(delayline_b95);

  preaddbit3 <=  delayline_b63 XOR delayline_b95_not XOR carrymux3;

  temp1_2 <=  delayline_b63 AND delayline_b95_not;

  temp2_2 <=  delayline_b95_not AND carrymux3;

  temp3_2 <=  delayline_b63 AND carrymux3;

  faddcarry3 <=  temp1_2 OR temp2_2 OR temp3_2;

  carrymux3 <= const_one WHEN ( phase_1_1 = '1' ) ELSE
               carryreg3;
  Carry_reg3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      carryreg3 <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF clk_enable = '1' THEN
        carryreg3 <= faddcarry3;
      END IF;
    END IF; 
  END PROCESS Carry_reg3_process;

  mem_addr <= preaddbit3 & preaddbit2 & preaddbit1;

  PROCESS(mem_addr)
  BEGIN
    CASE mem_addr IS
      WHEN "000" => memoutb1 <= "0000000000000000";
      WHEN "001" => memoutb1 <= "1111001001011010";
      WHEN "010" => memoutb1 <= "1110100100110101";
      WHEN "011" => memoutb1 <= "1101101110001111";
      WHEN "100" => memoutb1 <= "1011101110001111";
      WHEN "101" => memoutb1 <= "1010110111101001";
      WHEN "110" => memoutb1 <= "1010010011000100";
      WHEN "111" => memoutb1 <= "1001011100011110";
      WHEN OTHERS => memoutb1 <= "1001011100011110";
    END CASE;
  END PROCESS;

  memoutb1_cast <= resize(memoutb1(15 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 34);

  acc_out_shft <= resize(acc_out(33 DOWNTO 1), 34);

  add_temp <= resize(acc_out_shft, 35) + resize(memoutb1_cast, 35);
  addsub_add <= add_temp(33 DOWNTO 0);

  sub_temp <= resize(acc_out_shft, 35) - resize(memoutb1_cast, 35);
  addsub_sub <= sub_temp(33 DOWNTO 0);

  add_sub_out <= addsub_sub WHEN ( phase_1 = '1' ) ELSE
                      addsub_add;

  acc_in <= memoutb1_cast WHEN ( phase_1_1 = '1' ) ELSE
            add_sub_out;

  Acc_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      acc_out <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF clk_enable = '1' THEN
        acc_out <= acc_in;
      END IF;
    END IF; 
  END PROCESS Acc_reg_process;

  Finalsum_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      final_acc_out <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_1_1 = '1' THEN
        final_acc_out <= acc_out;
      END IF;
    END IF; 
  END PROCESS Finalsum_reg_process;

  output_da <= final_acc_out;

  output_typeconvert <= resize(shift_right(output_da(30 DOWNTO 0) + ( "0" & (output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15) & NOT output_da(15))), 15), 16);

  Output_Register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output_register <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF phase_1 = '1' THEN
        output_register <= output_typeconvert;
      END IF;
    END IF; 
  END PROCESS Output_Register_process;

  -- Assignment Statements
  filter_out <= std_logic_vector(output_register);
END rtl;
